[{"title":"js基础整理八————创建对象模式","date":"2017-09-29T07:04:54.270Z","path":"2017/09/29/jsCreateObject/","text":"js面向对象程序设计——几种创建对象的方式 刚好最近有笔试题说说js几种创建对象的模式，便写一写，理一理 创建对象 对象字面量 var obj = { hour: 12, day: 13, getTime: function(){ console.log(new Date()); } } 创建Object实例 var obj = new Object(); obj.hour = 10; 对象创建模式1.工厂模式 概念：工厂模式是软件工程领域一种广为人知的设计模式，这种模式，抽象了具体的创建过程。 优点：解决了创建多个相似对象的问题 缺点：没有解决对象的识别问题 实现 function createPerson(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name); } return o; } 2.构造函数模式 与createPerson对比： 1.没有显式地创建对象； 2.直接将属性和方法赋值给this对象； 3.没有return语句。 要创建Person的新实例，使用new操作符实际会发生以下四个步骤 创建一个对象 将构造函数的作用域赋值给新的对象（因此this就指向了这个新对象） 执行构造函数中的代码 返回新对象 对象的识别，使用instanceof 优点：创建自定义的构造函数对象意味着未来可以将它的实例标识为一种特定的类型。 缺点：每个方法都要在每个实例上重新创建一遍，即personal1和persoanal2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例，虽然可以使用定义全局方法例如 function Personal(name, age, job){ this.sayName = sayName; } function sayName(){ cossole.log(this.name); } 这样虽然可以解决上面的问题，可是当方法越来越多就会显得很混乱而且丝毫没有封装性可言。 实现： function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); } } var person1 = new Person(&apos;555&apos;, 55, &apos;666&apos;); var person1 = new Person(&apos;666&apos;, 66, &apos;555&apos;); 3 原型模式 实现的根据：每个函数都有一个prototype属性，这个属性时一个指针，指向一个对象，对象都具有可扩展属性。 实现： function Perosn(){ } Perosn.prototype.name = &apos;mark&apos;; Perosn.prototype.age = 29; Perosn.prototype.job = &apos;enlish&apos;; Perosn.prototype.sayName = function(){ console.log(this.name); } 理解：理解原型对象，可以查看我以前的内容 优点：解决了上面定义多个方法的问题，让多个对象的方法指向同一个Function实例 缺点：对象没有自己的属性，每次改动原型模式中的属性，其他对象额属性也会跟着改变 4 组合使用构造函数模式和原型模式 比较容易理解，就是将构造函数和原型模式结合起来，构造函数有自己的属性，使用原型扩展公用方法 实现 function Person(name. age, job){ this.name = name; this.age = age; this.job = job; this.friends = [&apos;Geroy&apos;, &apos;Scout&apos;]; } Person.prototype = { constructor: Person, sayName: function(){ console,log(name); } }","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理七————事件","date":"2017-09-29T07:04:54.269Z","path":"2017/09/29/js_7/","text":"js事件题目 编写一个通用的事件监听函数 描述事件冒泡的流程 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 知识点 通用事件绑定 btn.addEventListener(&apos;click&apos;, function (event){ e.preventDefault(); console.log(&apos;clicked&apos;); }); IE低版本兼容，attachEvent绑定事件 事件冒泡e.stopPropatation();// 阻止冒泡 代理 解答 编写一个通用的事件监听函数 描述事件冒泡的流程 沿着dom树往上找 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 Ajax题目 手动编写ajax，不依赖第三方库 跨域的几种实现方式 知识点 XMLHttpREquest var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, &apos;/api&apos;, false); xhr.onreadystatechange = function() { if(xhr.readyState == 4){ if(xhr.status == 200){ alert(xhr.responseText); } } } xhr.send(null); IE低版本使用ActiveXObject 状态码说明 0 - (未初始化) 还没有调用send() 方法 1 - (载入) 已调用send方法，正在发送 2 - (载入完成) send方法执行完成 3 - (交互) 正在解析响应内容 4 - (完成) 响应内容解析完成，可在客户端调用 2xx - 表示请求成功。如200 3xx - 需要重定向，浏览器直接跳转 4xx - 客户端请求错误，如404 5xx - 服务器端错误 跨域 什么是跨域 浏览器的同源策略，不允许ajax访问其他域接口 跨域条件：协议，域名，端口，有一个不同就算跨域 三个标签可以使用跨域 用于打点统计，统计网站可能是其他域 JSONP 实现原理 加载http://baozi.com/index.html 不一定服务器端真正有一个index.html文件 服务器可以根据请求，动态生成一个文件返回 同理于&lt;script src=&apos;http://baozi.com/spi.js&apos;&gt; 参会内容的格式 callback({x:100, y:200}) 服务器端设置http header 注意事项 所有的跨域请求都必须经过信息提供方允许 存储题目 cookie，sessionSorage和localStorage的区别 知识点 cookie 本身用于客户端和服务器端通信 但是它有本地存储的功能，于是就被“借用” 使用document.cookie=… 获取和修改即可 存储量太小，只有4kb 所有http请求都带着，会影响获取资源的效率 localStorage 和 sessionStorage HTML5 专门为存储而设计，最大容量5M API简单易用 localStorage.setItem(key, value);localStorage.getItem(key); 解决问题 cookie，sessionSorage和localStorage的区别 容量 是否会携带到ajax中 API易用性","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理六————js-web-api","date":"2017-09-29T07:04:54.254Z","path":"2017/09/29/js_6/","text":"js-web-apiDOM操作 题目 DOM是哪种基本的数据结构 DOM操作的常用API有哪些 DOM及诶单的attr和property有何区别 知识点 DOM本质 DOM节点操作 获取DOM prototype Attribute DOM结构操作 新增节点： document.creatElement();innerHTML 获取父元素 获取子元素 childNodes 和 children 的区别, childNodes 事无巨细全部返回 删除节点 BOM操作 题目 如何检测浏览器的类型 拆解url的各部分 知识点 navigator var ua = navigatoruserAgent screen location console.log(locationg.href); console.log(locationg.prorocol); console.log(locationg.pathname); console.log(locationg.search); console.log(locationg.hash); historyhistoryback(); historyforward();","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理五————js内置对象","date":"2017-09-29T07:04:54.253Z","path":"2017/09/29/js_5/","text":"js内置对象题目 获取2017-06-10 格式的日期 获取随机数，要求长度一致的字符串格式 写一个能遍历对象和数组的forEach函数 内置对象 Date Date.new(); // 当前时间的毫秒数 var dt = new Date(); dt.getTime(); //获取毫秒数 dt.getFullYear(); //年 dt.getMonth; // 月 （0-11） dt.getDay(); // 周几 dt.getData(); // 日 dt.getHours(); // 小时 dt.getMinutes(); // 分钟 dt.getSeconds(); // 秒 Math 获取随机数 Math.random(); 数组 Array forEach 遍历所有元素 every 判断所有元素是否符合条件 some 判断是否至少一个元素符合条件 sort 排序 map 对数组重新组装，生成新数组 filter 过滤符合条件的元素","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理四————异步，单线程","date":"2017-09-29T07:04:54.252Z","path":"2017/09/29/js_4/","text":"异步抛出问题 同步和异步的区别 一个关于setTimeout的笔试题 前端使用异步的场景有哪些 知识点 什么是异步（对比同步） 同步阻塞 异步不阻塞 前端使用异步的场景 定时任务： setTimeout, setInvercal 网络请求： ajax请求，动态加载 事件绑定 异步和单线程 console.log(100); setTimeout(function(){ console.log(200); }) console.log(300); 执行第一行，打印100 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事） 执行最后一行，打印300 待所有程序执行完，处于空闲状态，会立马看有没有暂存起来的要执行 发现暂存起来的setTimeout中函数无等待时间，就立即执行","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理三————作用域和闭包","date":"2017-09-29T07:04:54.238Z","path":"2017/09/29/js_3/","text":"js 作用域和闭包抛出问题 说一下对变量提升的理解 说明this的集中不同场景 创建10个标签，点击时弹出对应的序号 如何理解作用域 实际开发中闭包的应用 知识点 执行上下文 范围： 一段或者一个函数 全局：变量定义、函数声明 函数： 变量定义、函数声明、this、arguments console.log(a); // undefined var a = 100; this this 要在执行时才能确定，定义时无法确定 var a = { name: &apos;A&apos;, fn: function(){ console.log(this.name); } } a.fn(); // this === a a.fn.call({name: &apos;B&apos;}) // this === {name: &apos;B&apos;} var fn1 = a.fn fn1() // this === window 作为构造函数执行 作为对象属性执行 作为普通函数执行 call apply bind 作用域 没有块级作用域 函数和全局作用域 函数作用域在定义是确定 作用域链 自由变量，当前作用域没有定义的变量 闭包 函数作为返回值 函数作为参数传递 解决问题 说一下对变量提升的理解 变量定义 函数声明 说明this的集中不同场景 创建10个标签，点击时弹出对应的序号 for(var i = 0; i &lt; 10; i++){ (function ())(i) a = document.creatElement(&apos;a&apos;); a.innerHTML = i + &apos;&lt;br&gt;&apos;; a.addEventListener(&apos;click&apos;, function (e){ e.preventDefault(); alert(i); }) } 如何理解作用域 自由变量 作用域链，即自由变量的查找 实际开发中闭包的应用","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理二————原型对象和原型链","date":"2017-09-29T07:04:54.233Z","path":"2017/09/29/js_2/","text":"js 原型对象和原型链抛出问题 如何判断一个变量是数组类型 写一个原型链继承的例子 描述new一个对象的过程 zepto源码中如何使用原型链 知识点构造函数function Foo(name, age){ this.name = name; this.age = age; } var f = new Foo(&apos;zhangsan&apos;, 20); 构造函数-扩展var a = {} 和 var a = new Object()效果相同var a = [] 和 var a = new Array()效果相同function Foo(){} 和 var Foo = new Function(){} 效果相同 原型规则和实例 所有的引用类型都有对象的特性，即可自由扩展属性 所有的引用类型都有一个__proto__属性，属性值为普通的对象 所有的函数有一个prototype 属性 所有的引用类型__proto__指向 构造函数的 prototype var obj = {}; obj.a = 100; var arr = []; arr.a = 100; function fn(){} fn.a = 100; 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去他的__proto__中寻找 function Foo(name){ this.name = name; } Foo.prototype.alertName = function () { alert(this.name); } var f = new Foo(&apos;zhangsan&apos;); f.printName = function () { console.log(this.name); } f.printName(); f.alertName(); 原型链function Foo(name){ this.name = name; } Foo.prototype,alertName = function () { alert(this.name); } var f = new Foo(&apos;zhangsan&apos;); f.printName = function () { console.log(this.name); } f.printName(); f.alertName(); f.toString(); // 要去f.__proto__.__proto__中寻找 instanceof用于判断应用类型是哪个构造函数 f instanceof Foo 判断逻辑 f 的 __proto__ 一层一层的往上找 在试着判断 f instanceof Object 解决问题 如何判断一个变量是数组类型 var arr = []; arr instanceof Array //true //当网页中存在框架时，可能会出现问题 Object.prototype.toString.call(val) === &apos;[object Array]&apos; //true 写一个原型链继承的例子 function Amimal(){} function Dog(){} Dog.prototype = new Animal(); 描述new一个对象的过程 function Foo(name, age){ this.name = name; this.dog = dog // return this } zepto源码中如何使用原型链","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理一————数据类型","date":"2017-09-29T07:04:54.221Z","path":"2017/09/29/js_1/","text":"前言最近打算把js梳理一下，也留着自己看，这是一篇笔记性质的文章。 问题：typeof 会返回哪些值问题：js数据类型转换 js的数据类型在回答上面问题之前，首先我们得知道js 有哪些数据类型。js的数据类型总分为两类，值类型和引用类型。值类型包括：Number，String，Boolean引用类型包括：Array，Object，函数这里也不多介绍其他的了。 typeof的返回值typeof undefined //undefined typeof 123 // number typeof &apos;abc&apos; //string typeof true //boolean typeof {} //object typeof [] //object typeof null //object typeof console.log //function","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"js基础整理九————继承","date":"2017-09-29T07:04:54.219Z","path":"2017/09/29/inherit/","text":"继承 这是一篇关于js继承的文章，具体主要的js高程上面都有，这里只是简单理一理，外加一些自己的看法。 下面直接上干货 原型链继承 基础依赖:可以查看我以前写的文章原型对象和原型链 实例 function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;your name:&apos; + this.name); } function Child(name) { this.name = name; } Child.prototype = new Parent(&apos;Nickle&apos;); Child.prototype.constructor = Child; var child = new Child(&apos;Jack&apos;); child.sayName(); 打印结果为 your name Jack - 缺点 * 当超类中存在引用类型时，该属性会被所有的实例共享 * 在创建子类的过程中无法向父类传递数据，让子类使用父类的构造器，而是只能通过new Parent(‘Nickle’) 去解决 在别的地方相似的文章下面看到一个问题：子类的 __proto__ 属性为什么指向父类。而不是指向Function.prototype，这里子类是Child，父类为Parent。我想他可能吧概念搞混淆了，所有的引用类型的__proto__指向的是构造函数的prototype，即方法Child和Parent的__proto__指向的都是Function.prototype。在本例中实例child的__proto__指向的是构造函数Child的prototype，而我们已经做了这步操作：Child.prototype = new Parent(‘Nickle’);使得Child.prototype成为了parent的实例。下面给出测试 // 为了测试我将继承写为 var parent = new Parent(&apos;Nickle&apos;); Child.prototype = parent; Child.__proto__ === Parent.__proto__; // true Child.__proto__ === Function.prototype; // true child.__proto__ === parent; // true child.__proto__.__proto__ === Parent.prototype； // true 借用构造函数 基础依赖：即在子类的构造函数中调用超类型构造函数，可以通过call 和 apply来进行。 实例 function Parent(name) { this.colors = [&apos;white&apos;, &apos;black&apos;, &apos;green&apos;]; this.name = name } function Child(name) { // 完成了继承，同时还实现了传递参数 Parent.call(this, &apos;Nickle&apos;); } var child1 = new Child(); child1.colors.push(&apos;red&apos;); console.log(child1.colors); // [&quot;white&quot;, &quot;black&quot;, &quot;green&quot;, &quot;red&quot;] var child2 = new Child(); console.log(child2.colors); // [&quot;white&quot;, &quot;black&quot;, &quot;green&quot;] * 缺点：函数无法复用。 组合式继承：使用原型和借用构造函数 实例 function Parent(name) { this.name = name; this.colors = [&apos;white&apos;, &apos;black&apos;, &apos;green&apos;]; } Parent.prototype.sayName = function() { console.log(this.name); } function Child(age, name) { Parent.call(this); this.age = age; } Child.prototype = new Parent(); Child.prototype.constructor = Child; Child.prototype.sayAge = function() { console.log(this.age); } var child1 = new Child(&apos;Nickle&apos;, 20); child1.colors.push(&apos;red&apos;); // [&quot;white&quot;, &quot;black&quot;, &quot;green&quot;, &quot;red&quot;] child1.sayName(); // Nickle child1.sayAge(); // 20 var child2 = new Child(&apos;Grey&apos;, 27); console.log(child2.colors); // [&quot;white&quot;, &quot;black&quot;, &quot;green&quot;] child2.sayName(); // Grey child2.sayAge(); // 27","tags":[{"name":"js","slug":"js","permalink":"http://wangcheng007.github.io/tags/js/"},{"name":"整理复习","slug":"整理复习","permalink":"http://wangcheng007.github.io/tags/整理复习/"}]},{"title":"正则整理","date":"2017-09-29T07:04:54.209Z","path":"2017/09/29/zhengze/","text":"正则学习1.字符介绍 ^： 匹配起始位置 例如： ^ttt 即匹配以ttt 开头的字符串 $： 匹配字符串结尾 例如： $ttt 即匹配以ttt 结尾的字符串 \\b： 匹配单词，例如 \\bis\\b 即匹配单词is \\d： 匹配数字， 例如 匹配一个三个数字开头的字符串可以写成 ^\\d\\d\\d \\w： 匹配字母，数字，下划线，例如我要匹配一个字符串为 dwqdn61_dwq 则正则表达式为 \\w+ \\s： 匹配空格， 例如字符串为 ‘a b c’，则正则表达式为 ‘\\w\\s\\w\\s\\w’一个字符后跟一个空格，如果要匹配多个空格，则为\\s+ .： 匹配除了换行符以外的任意字符 [pdwp]： 字符组，匹配包含括号中元素的字符串例如[a-z] 只能匹配小些字符 2.几种反义写法很简单，即小写字母改成大写字母 \\W： 匹配任意部位字母，数字，下划线 \\S： 匹配不是空白符的字符 \\D： 匹配任意非数字的字符 \\B： 匹配不是单词开头或结束的位置 [^abc]： 匹配除了abc以外的字符 3.量词 （贪婪）：匹配0次或者多次，如a\\则匹配0个a或者多个a +（懒惰）：匹配1次或者多次，如a+则匹配1个a或者多个a ？（占有）：匹配0次或者1次，如a？则匹配0个或者1个a {n}： 匹配n个字符，如a{3}则匹配3个a {n，m}： 匹配n到m个字符，如a{3,4}则匹配3个a或者4个a {n，}： 匹配最少n个字符，如a{3，}则匹配最少3个a 注意： 以上的量词都只是匹配最靠近的字符，即如果正则表达式为 ‘ab*‘ 即匹配的是字符串是a后面的b为0个或者多个，而不是ab的个数为0个或者多个。能匹配的字符串是a，ab，abb，而不是abab之类,如果要匹配以ab为单位则正则可以写成（ab）+ 4.正则进阶 捕获分组 概念：在一个括号中的内容如(\\d)\\d,前面(\\d)就是一个捕获分组，可以对捕获分组进行后向引用，即我在后面的正则中可以使用前面的捕获分组。例如(\\d)\\d\\1这里的\\1就是对(\\d)的后向引用。 常用用法： (exp)：匹配exp，并自动捕获文本到自命名空间 (? exp)： 匹配exp，并捕获文本到名称为name的空间，使用时为\\k (?:exp)： 匹配exp，不捕获匹配的文本，也不给该分组分配组号 (?=exp)： 匹配exp前面的位置，如’What are you’,该正则为(?.+(?=you))这里取you前面的所有字符成一个分组，该分组名为txt，内容为’What are ‘ (?&lt;=exp)： 匹配exp后面的位置，如’What are you’,该正则为(?(?&lt;=How).+)这里取How后面的所有字符成一个分组，该分组名为txt，内容为’ are you’ (?!exp)： 匹配后面跟的不是exp的位置，如’123abc’,正则(\\d{3}(?!\\d)),匹配三个数字后面非数字的结果 (?&lt;!exp)： 匹配前面不是exp的位置，如’abc123’,正则为(?&lt;!\\d)\\d{3},匹配前面的3个非数字的集合 注意： 这里的捕获分组，捕获的是第一次匹配的文本，而不是正则表达式，例如：13[1-9]-(\\d{4})-\\1，字符串是：131-5200-1230，这里捕获的是5200这个文本，而不是\\d{4}这个表达式，所以这个字符串和正则不匹配 5.正则实战 匹配Email地址 分析：email地址由一排数字，字母，或下划线组成+@+字母+.com组成 编写：^\\w+@\\w+.com$ 匹配131到139开头的电话号码 分析：手机号由11位数字组成 编写：^13[1-9]-\\d{4}-\\d{4}$ 匹配QQ号 分析：QQ由最少5位组成，除了第一位不为0 编写：[1-9]\\d{4,}","tags":[{"name":"正则","slug":"正则","permalink":"http://wangcheng007.github.io/tags/正则/"}]},{"title":"less学习","date":"2017-09-16T13:47:38.189Z","path":"2017/09/16/less/","text":"less学习1.常量常量的声明：@常量名：数值;常量的使用：@常量名 2.混合混合的使用：可以使用定义过的class如： .border(){ border:2px solid black } .btn{ width:100px; height:100px; .border; } 也可以传入参数如: .border(@width){ border:@width solid black } .btn{ width:100px; height:100px; .border(2px); } 初始化参数： .border(@width:2px){ border:@width solid black } .btn{ width:100px; height:100px; .border(); } 3.匹配模式编写三角 .sanjiao{ width: 0px; height: 0px; border-width: 10px; border-color: red transparent transparent transparent; border-style: solid; } //匹配模式 类似编程思想if判断 .triangle(top,@w:5px,@c:black){ border-width: @w; border-color: transparent transparent @c transparent; border-style: solid; } .triangle(bottom,@w:5px,@c:black){ border-width: @w; border-color: @c transparent transparent transparent; border-style: solid; } //调用 .sanjiao{ width: 0px; height: 0px; .triangle(bottom); } //每次调用都存在一个等同于回掉函数的存在即 .triangle(@_,@w:5px,@c:black){ width: 0px; height: 0px; } //@_：是一个固定模式，现在每次调用.triangle都会调用上面的css 代码 4.运算可以在css代码中进行加减乘除运算。还可以进行颜色的加减法运算，不过一般不使用。 5.嵌套规则 //html代码 &lt;ul class=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这是测试文字1&lt;span&gt;10:01&lt;/1span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这是测试文字2&lt;span&gt;10:01&lt;/1span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;这是测试文字3&lt;span&gt;10:01&lt;/1span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; //less代码 .list{ margin:0px; padding:0px; list-style: none; li{ height: 30px; line-height: 30px; color: black; margin-bottom: 5px; } a{ float: left; //&amp; 上一层选择器 &amp;:hover{ color: red; } } span{ float: right; } } 6.arguments变量.border_arg(@w:2px,@c:red,@xx:solid){ border:@arguments; } .text_border{ .border_arg(); } //编译的css .text_border { border: 2px red solid; } 7.避免编译对于less无法识别的字符，进行该操作，比如微软的滤镜之类。 //css3新方法calc，浏览器会计算这里面的值并显示 .text_03{ width:calc(300px-30px); height: 100px; background-color: red; } //编译出来的css为 .text_03 { width: calc(270px); height: 100px; background-color: red; } //但我们想要的效果并不是这样，我们想要浏览器自动运算，需要less不执行这一段的编译，只需要加上~&apos;&apos;,即可。 .text_03{ width:~&apos;calc(300px-30px)&apos;; height: 100px; background-color: red; } //编译后为 .text_03 { width: calc(300px-30px); height: 100px; background-color: red; } //我本人在编写这一段代码的时候遇到一个问题，在less中编写 .text_03{ width:calc(300px -30px); height: 100px; background-color: red; } //即300px 后面多了一个空格，编译后的css为 .text_03 { width: calc(300px -30px); height: 100px; background-color: red; } //看着和避免编译后的结果是一样的，其实不然，浏览器并不能执行。但是如果改成 .text_03 { width: calc(300px- 30px); height: 100px; background-color: red; } //编译成css后就和没有避免编译后的结果一样","tags":[{"name":"less","slug":"less","permalink":"http://wangcheng007.github.io/tags/less/"},{"name":"基础","slug":"基础","permalink":"http://wangcheng007.github.io/tags/基础/"}]},{"title":"微信公众号支付开发总结二","date":"2017-06-28T14:38:17.937Z","path":"2017/06/28/WeChatPay_2/","text":"前言 接着昨天的写。微信公众号支付开发的第三步，也是最后一步，通过预下单的ID发起支付请求。 通过预下单的ID发起支付请求 获取signature 这里采用SHA－１ 加密方法（必为无论新版旧版） String timestamp = myDate.getTime() / 1000 + &quot;&quot;; String nonce_str = CommonUtil.create_nonce_str(); String string1; String signature = &quot;&quot;; String jsapi_ticket = WeixinUtil.getjsapi_ticket(); // 注意这里参数名必须全部小写，且必须有序 //jsapi_ticket 每7200秒 更新一次 建议写入进程 自动获取 string1 = &quot;jsapi_ticket=&quot; + jsapi_ticket + &quot;&amp;noncestr=&quot; + nonce_str + &quot;&amp;timestamp=&quot; + timestamp + &quot;&amp;url=&quot; + url; try { MessageDigest crypt = MessageDigest.getInstance(&quot;SHA-1&quot;); crypt.reset(); crypt.update(string1.getBytes(&quot;UTF-8&quot;)); signature = CommonUtil.byteToStr(crypt.digest()); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;noncestr&quot;, nonce_str); map.put(&quot;timestamp&quot;, timestamp); map.put(&quot;signature&quot;, signature); public static String byteToStr(byte[] byteArray) { String strDigest = &quot;&quot;; for (int i = 0; i &lt; byteArray.length; i++) { strDigest += byteToHexStr(byteArray[i]); } return strDigest; } public static String byteToHexStr(byte bytes) { char[] Digit = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; }; char[] tempArr = new char[2]; tempArr[0] = Digit[(bytes &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[bytes &amp; 0X0F]; String s = new String(tempArr); return s; } 注入微信config，这里的参数为上面生成signature的参数值 wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;wx7c1af8e43fa7304d&apos;, // 必填，公众号的唯一标识 timestamp: timestamp, // 必填，生成签名的时间戳 nonceStr: nonceStr, // 必填，生成签名的随机串 signature: signature,// 必填，签名，见附录1 jsApiList: [&apos;chooseWXPay&apos;] // 必填，需要使用的JS接口列表，这里只写支付的 }); 再算签名 String nonce = CommonUtil.create_nonce_str().replace(&quot;-&quot;, &quot;&quot;); Date myDate = new Date(); String timestamp = myDate.getTime() / 1000 + &quot;&quot;; // 再算签名 String newPrepay_id = &quot;prepay_id=&quot; + prepay_id; String args = &quot;appId=wx7c1af8e43fa7304d&quot; + &quot;&amp;nonceStr=&quot; + nonce + &quot;&amp;package=&quot; + newPrepay_id + &quot;&amp;signType=MD5&quot; + &quot;&amp;timeStamp=&quot;+ timestamp //此处timeStamp 为大写 S 。绝对注意 + &quot;&amp;key=cqutcqutcqutcqutcqutcqutcqutcqut&quot;; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); md5.reset(); md5.update(args.getBytes(&quot;UTF-8&quot;)); String paySign = CommonUtil.byteToStr(md5.digest()).toUpperCase(); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;noncestr&quot;, nonce); map.put(&quot;timestamp&quot;, timestamp); map.put(&quot;prepay_id&quot;, newPrepay_id); map.put(&quot;paySign&quot;, paySign); 调用js 发起微信支付请求，这次数据第二次获取签名的数据值 wx.chooseWXPay({ timestamp : back.timestamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但 最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr : back.noncestr, // 支付签名随机串，不长于 32 位 package : back.prepay_id, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=***） signType : &quot;MD5&quot;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos; paySign : back.paySign, success : function(res) { } }） 遇到的坑 获取第一次签名是采用的加密方式是 ＳＨＡ－１ 也不用转换成大写 注入weixin.config 时间戳timestamp 中的s为小写 第一次签名是也为小写 第二次算签名package的值应该为 “prepay_id=” + prepay_id 前面加上 第二次算签名时时间戳timeStamp的S为大写，大写，大写。重要的事情说三遍 发起支付请求时各参数为获取第二次签名时的参数值","tags":[{"name":"微信公众号支付","slug":"微信公众号支付","permalink":"http://wangcheng007.github.io/tags/微信公众号支付/"}]},{"title":"微信公众号支付开发总结一","date":"2017-06-27T01:21:16.126Z","path":"2017/06/27/WechatPay_1/","text":"前言 前段时间开发了一个基于微信的电商平台，里面有涉及到微信公众号支付，不断踩坑。 一、微信支付开发的基本流程 微信开发分为三个流程 1.通过code授权用户权限获取用户的openid 2.通过获取的 openid ，商户的 appid ，商户key，商户的mch_ID，统一下单 获取预下单的ID 3.通过预下单的ID发起支付请求。 二、通过code授权用户权限获取用户的openid 第一步通过code获取openID，我的队友 已经获取到了openID 这里 就跳过 三、通过openID 统一下单获取预下单的ID 1、建立Payinfo 实体类 public class Payinfo implements Serializable { private static final long serialVersionUID = 5637164279924222380L; private String appid; private String mch_id; private String device_info; private String nonce_str; private String sign; private String body; private String attach; private String out_trade_no; private int total_fee; private String spbill_create_ip; private String notify_url; private String trade_type; private String openid; //get（） set（）方法 } 2、包装实体 Payinfo payInfo = new Payinfo(); payInfo.setAppid(&quot;xxxxxxxxxxxx&quot;); //填公众号的APPID payInfo.setDevice_info(&quot;WEB&quot;); payInfo.setMch_id(&quot;xxxxxxxx&quot;);//填商户的ID payInfo.setNonce_str(CommonUtil.create_nonce_str().replace(&quot;-&quot;, &quot;&quot;));//随机字符串 payInfo.setBody(&quot;xxxxxxx&quot;);//设置支付的名称 payInfo.setOut_trade_no(out_trade_no + tt);//下单的订单号 唯一 payInfo.setTotal_fee((int) total_fee);//下单的金额 单位分 payInfo.setSpbill_create_ip(CommonUtil.getIpAddr(request));//获取ip地址 payInfo.setNotify_url(notify_url);//回调的url payInfo.setTrade_type(&quot;JSAPI&quot;);//支付类型 payInfo.setOpenid(openId);//客户的openID 随机字符串的获取 CommonUtil.java public static String create_nonce_str() { return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); } IP地址的获取 CommonUtil.java public static String getIpAddr(HttpServletRequest request) { InetAddress addr = null; try { addr = InetAddress.getLocalHost(); } catch (UnknownHostException e) { return request.getRemoteAddr(); } byte[] ipAddr = addr.getAddress(); String ipAddrStr = &quot;&quot;; for (int i = 0; i &lt; ipAddr.length; i++) { if (i &gt; 0) { ipAddrStr += &quot;.&quot;; } ipAddrStr += ipAddr[i] &amp; 0xFF; } return ipAddrStr; } 统一下单签名的获取（所有的签名必须转换为大写） public String getSign(Payinfo payInfo) throws Exception { String signTemp = &quot;appid=&quot; + payInfo.getAppid() + &quot;&amp;body=&quot; + payInfo.getBody() + &quot;&amp;device_info=&quot; + payInfo.getDevice_info() + &quot;&amp;mch_id=&quot; + payInfo.getMch_id() + &quot;&amp;nonce_str=&quot; + payInfo.getNonce_str() + &quot;&amp;notify_url=&quot; + payInfo.getNotify_url() + &quot;&amp;openid=&quot; + payInfo.getOpenid() + &quot;&amp;out_trade_no=&quot; + payInfo.getOut_trade_no() + &quot;&amp;spbill_create_ip=&quot; + payInfo.getSpbill_create_ip() + &quot;&amp;total_fee=&quot; + payInfo.getTotal_fee() + &quot;&amp;trade_type=&quot; + payInfo.getTrade_type() + &quot;&amp;key=&quot;xxxxxxxxxxx&quot;; // 这个key注意为32位 MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); md5.reset(); md5.update(signTemp.getBytes(&quot;UTF-8&quot;)); String sign = CommonUtil.byteToStr(md5.digest()).toUpperCase(); return sign; } 3、将实体包装成xml private static XStream xstream = new XStream(new XppDriver() { public HierarchicalStreamWriter createWriter(Writer out) { return new PrettyPrintWriter(out) { // 增加CDATA标记 boolean cdata = true; @SuppressWarnings(&quot;rawtypes&quot;) public void startNode(String name, Class clazz) { super.startNode(name, clazz); } protected void writeText(QuickWriter writer, String text) { if (cdata) { writer.write(&quot;&lt;![CDATA[&quot;); writer.write(text); writer.write(&quot;]]&gt;&quot;); } else { writer.write(text); } } }; } }); public static String payInfoToXML(Payinfo pi) { xstream.alias(&quot;xml&quot;, pi.getClass()); return xstream.toXML(pi); } 4、改变xml的格式并发送到微信的服务器，获取返回的值 并且打印日志 查看信息 Map&lt;String, String&gt; map = CommonUtil.httpsRequestToXML( &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;, &quot;POST&quot;, payInfoToXML(payInfo).replace(&quot;__&quot;, &quot;_&quot;).replace(&quot;&lt;![CDATA[&quot;, &quot;&quot;).replace(&quot;]]&gt;&quot;, &quot;&quot;)); System.out.println(&quot;------------------------&quot;); System.out.println(&quot;map 是&quot; + map); System.out.println(&quot;return_code 是&quot; + map.get(&quot;return_code&quot;)); System.out.println(&quot;return_msg 是&quot; + map.get(&quot;return_msg&quot;)); System.out.println(&quot;prepay_id 是&quot; + map.get(&quot;prepay_id&quot;)); 5、遇到的坑 下单时，金额报错，金额的类型是int类型，单位是分 下单时，签名错误，签名是根据编码从小到大排列先把支付实体包装好，最后再加上key 今天就到这里，第三步，请看下篇文章。","tags":[{"name":"微信公众号支付","slug":"微信公众号支付","permalink":"http://wangcheng007.github.io/tags/微信公众号支付/"}]},{"title":"css3之选择器","date":"2017-03-16T07:52:17.619Z","path":"2017/03/16/css3_1/","text":"1.属性选择器实际用处并不大的^,$,*,分别代表开头，结尾，包含。简单例子： a[class^=&quot;column&quot;]{background:red;} a[href$=&quot;.doc&quot;]{background:green;} a[title*=&quot;box&quot;]{background:blue;} 分别代表：包含column 开头的类名，包含.doc 结尾的href属性，包含box的title属性。 2.伪类选择器常见的伪类选择器： 1.类型1：not，：root,：empty,：target(值得注意） #brand:target { background: orange; color: #fff; }简单例子，这里选择器选择的就是id为brand的对象。开始不是出于出发状态，点击出发条件即#brand后触发。2.类型2：first-child,last-child,nth-child(n),nth-last-child(n) 这类简单，基本就是一些匹配条件。 3.伪元素enabled，disabled，checked，selection，read-only，read-write，before，after。","tags":[{"name":"css3","slug":"css3","permalink":"http://wangcheng007.github.io/tags/css3/"},{"name":"简单","slug":"简单","permalink":"http://wangcheng007.github.io/tags/简单/"}]},{"title":"css3之变形与动画","date":"2017-03-16T07:52:17.617Z","path":"2017/03/16/css3_2/","text":"1.css变形属性值：transform旋转 rotate，拉伸 shew，缩放 scale，位移 translate，以及矩阵 matrix。说一下最后一个矩阵 matrix 函数这个函数有6个参数transform：matrix（a,b,c,d,f,e）虽然这个函数的参数很多，实际上这些个参数对应的矩阵就是a c eb d f0 0 1就是这么简单的一个矩阵，那么按照我们的线代知识，这个矩阵和矩阵xy1这个矩阵相乘得到的就是矩阵就是 ax+cy+ebx+dy+f0+0+1转变后的水平坐标就成了ax+cy+e，垂直坐标就成了bx+dy+f举个例子：transform： matrix(1,0,0,1,30,30)现在我们假定原来的坐标是（0，0），那计算转换后的坐标焦点就成了（30，30），即坐标从（0，0）转换到了（30，30）。简而言之现在的transform： matrix(1,0,0,1,30,30)就相当于transform： translate(30px,30px)，这里值得要注意的地方是 translate，shew，scale，rotate 都是需要写上单位的。总结下来你就会发现 matrix 表现偏移就是 matrix(无关，无关，无关，无关，水平偏移，垂直偏移) 剩下的也就不必多说了，缩放对应的参数是 a和d ，拉伸和旋转涉及到三角函数不想说话，拉伸和旋转其实使用 shew和rotate 比使用 matrix 更为方便。 属性值：transition该属性包括：transition-propety ：设置变换的属性名称，默认为all，也可以指定特定的属性变换transition-duration ：设置过度需要的时间transition-timing-function ：规定速度效果的速度曲线，默认为ease（规定慢速开始，然后变快，然后慢速结束的过渡效果），其他的还有linear（规定以相同速度开始至结束的过渡效果）ease-in（规定以慢速开始的过渡效），ease-out（规定以慢速结束的过渡效果）和ease-in-out（规定以慢速开始和结束的过渡效果）。transition-delay ：定义过度效果何时开始 2.css动画keyframes 介绍在css3中以@keyframes开始 后面跟上动画名称加{…}动画内容。 animation 属性介绍animation-name ：要运行的动画名称animation-during ：设置动画播放时间animation-timing-function ：设置动画开始方式 （属性值与transition-timing-function相同）animation-delay ：设置动画延后执行时间animation-iteration-count ：设置动画的播放次数，通常为整数，如果设置为 infinte则一直循环动画animation-direction ：设置动画的播放方向，默认值为 normal（每次都是向前播放），如果设置为 alternate （动画播放在第偶数次向前播放，第奇数次向反方向播放）。","tags":[{"name":"css3","slug":"css3","permalink":"http://wangcheng007.github.io/tags/css3/"},{"name":"简单","slug":"简单","permalink":"http://wangcheng007.github.io/tags/简单/"}]}]