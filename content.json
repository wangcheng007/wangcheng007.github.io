[{"title":"微信支付开发总结","date":"2017-06-27T01:21:16.126Z","path":"2017/06/27/WechatPay_1/","text":"前言 前段时间开发了一个基于微信的电商平台，里面有涉及到微信公众号支付，不断踩坑。 一、微信支付开发的基本流程微信开发分为三个流程 1.通过code授权用户权限获取用户的openid 2.通过获取的 openid ，商户的 appid ，商户key，商户的mch_ID，统一下单 获取预下单的ID 3.通过预下单的ID发起支付请求。 二、通过code授权用户权限获取用户的openid 第一步通过code获取openID，我的队友 已经获取到了openID 这里 就跳过 三、通过openID 统一下单获取预下单的ID 1、建立Payinfo 实体类 public class Payinfo implements Serializable { private static final long serialVersionUID = 5637164279924222380L; private String appid; private String mch_id; private String device_info; private String nonce_str; private String sign; private String body; private String attach; private String out_trade_no; private int total_fee; private String spbill_create_ip; private String notify_url; private String trade_type; private String openid; //get（） set（）方法 } 2、包装实体 Payinfo payInfo = new Payinfo(); payInfo.setAppid(&quot;xxxxxxxxxxxx&quot;); //填公众号的APPID payInfo.setDevice_info(&quot;WEB&quot;); payInfo.setMch_id(&quot;xxxxxxxx&quot;);//填商户的ID payInfo.setNonce_str(CommonUtil.create_nonce_str().replace(&quot;-&quot;, &quot;&quot;));//随机字符串 payInfo.setBody(&quot;xxxxxxx&quot;);//设置支付的名称 payInfo.setOut_trade_no(out_trade_no + tt);//下单的订单号 唯一 payInfo.setTotal_fee((int) total_fee);//下单的金额 单位分 payInfo.setSpbill_create_ip(CommonUtil.getIpAddr(request));//获取ip地址 payInfo.setNotify_url(notify_url);//回调的url payInfo.setTrade_type(&quot;JSAPI&quot;);//支付类型 payInfo.setOpenid(openId);//客户的openID 随机字符串的获取 CommonUtil.java public static String create_nonce_str() { return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); } IP地址的获取 CommonUtil.java public static String getIpAddr(HttpServletRequest request) { InetAddress addr = null; try { addr = InetAddress.getLocalHost(); } catch (UnknownHostException e) { return request.getRemoteAddr(); } byte[] ipAddr = addr.getAddress(); String ipAddrStr = &quot;&quot;; for (int i = 0; i &lt; ipAddr.length; i++) { if (i &gt; 0) { ipAddrStr += &quot;.&quot;; } ipAddrStr += ipAddr[i] &amp; 0xFF; } return ipAddrStr; } 统一下单签名的获取（所有的签名必须转换为大写） public String getSign(Payinfo payInfo) throws Exception { String signTemp = &quot;appid=&quot; + payInfo.getAppid() + &quot;&amp;body=&quot; + payInfo.getBody() + &quot;&amp;device_info=&quot; + payInfo.getDevice_info() + &quot;&amp;mch_id=&quot; + payInfo.getMch_id() + &quot;&amp;nonce_str=&quot; + payInfo.getNonce_str() + &quot;&amp;notify_url=&quot; + payInfo.getNotify_url() + &quot;&amp;openid=&quot; + payInfo.getOpenid() + &quot;&amp;out_trade_no=&quot; + payInfo.getOut_trade_no() + &quot;&amp;spbill_create_ip=&quot; + payInfo.getSpbill_create_ip() + &quot;&amp;total_fee=&quot; + payInfo.getTotal_fee() + &quot;&amp;trade_type=&quot; + payInfo.getTrade_type() + &quot;&amp;key=&quot;xxxxxxxxxxx&quot;; // 这个key注意为32位 MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); md5.reset(); md5.update(signTemp.getBytes(&quot;UTF-8&quot;)); String sign = CommonUtil.byteToStr(md5.digest()).toUpperCase(); return sign; } 3、将实体包装成xml private static XStream xstream = new XStream(new XppDriver() { public HierarchicalStreamWriter createWriter(Writer out) { return new PrettyPrintWriter(out) { // 增加CDATA标记 boolean cdata = true; @SuppressWarnings(&quot;rawtypes&quot;) public void startNode(String name, Class clazz) { super.startNode(name, clazz); } protected void writeText(QuickWriter writer, String text) { if (cdata) { writer.write(&quot;&lt;![CDATA[&quot;); writer.write(text); writer.write(&quot;]]&gt;&quot;); } else { writer.write(text); } } }; } }); public static String payInfoToXML(Payinfo pi) { xstream.alias(&quot;xml&quot;, pi.getClass()); return xstream.toXML(pi); } 4、改变xml的格式并发送到微信的服务器，获取返回的值 并且打印日志 查看信息 Map&lt;String, String&gt; map = CommonUtil.httpsRequestToXML( &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;, &quot;POST&quot;, payInfoToXML(payInfo).replace(&quot;__&quot;, &quot;_&quot;).replace(&quot;&lt;![CDATA[&quot;, &quot;&quot;).replace(&quot;]]&gt;&quot;, &quot;&quot;)); System.out.println(&quot;------------------------&quot;); System.out.println(&quot;map 是&quot; + map); System.out.println(&quot;return_code 是&quot; + map.get(&quot;return_code&quot;)); System.out.println(&quot;return_msg 是&quot; + map.get(&quot;return_msg&quot;)); System.out.println(&quot;prepay_id 是&quot; + map.get(&quot;prepay_id&quot;)); 5、遇到的坑 下单时，金额报错，金额的类型是int类型，单位是分 下单时，签名错误，签名是根据编码从小到大排列先把支付实体包装好，最后再加上key 今天就到这里，第三步，请看下篇文章。","tags":[{"name":"微信支付","slug":"微信支付","permalink":"http://wangcheng007.github.io/tags/微信支付/"}]},{"title":"css3之选择器","date":"2017-03-16T07:52:17.619Z","path":"2017/03/16/css3_1/","text":"1.属性选择器实际用处并不大的^,$,*,分别代表开头，结尾，包含。简单例子： a[class^=&quot;column&quot;]{background:red;} a[href$=&quot;.doc&quot;]{background:green;} a[title*=&quot;box&quot;]{background:blue;} 分别代表：包含column 开头的类名，包含.doc 结尾的href属性，包含box的title属性。 2.伪类选择器常见的伪类选择器： 1.类型1：not，：root,：empty,：target(值得注意） #brand:target { background: orange; color: #fff; }简单例子，这里选择器选择的就是id为brand的对象。开始不是出于出发状态，点击出发条件即#brand后触发。2.类型2：first-child,last-child,nth-child(n),nth-last-child(n) 这类简单，基本就是一些匹配条件。 3.伪元素enabled，disabled，checked，selection，read-only，read-write，before，after。","tags":[{"name":"css3","slug":"css3","permalink":"http://wangcheng007.github.io/tags/css3/"},{"name":"简单","slug":"简单","permalink":"http://wangcheng007.github.io/tags/简单/"}]},{"title":"css3之变形与动画","date":"2017-03-16T07:52:17.617Z","path":"2017/03/16/css3_2/","text":"1.css变形属性值：transform旋转 rotate，拉伸 shew，缩放 scale，位移 translate，以及矩阵 matrix。说一下最后一个矩阵 matrix 函数这个函数有6个参数transform：matrix（a,b,c,d,f,e）虽然这个函数的参数很多，实际上这些个参数对应的矩阵就是a c eb d f0 0 1就是这么简单的一个矩阵，那么按照我们的线代知识，这个矩阵和矩阵xy1这个矩阵相乘得到的就是矩阵就是 ax+cy+ebx+dy+f0+0+1转变后的水平坐标就成了ax+cy+e，垂直坐标就成了bx+dy+f举个例子：transform： matrix(1,0,0,1,30,30)现在我们假定原来的坐标是（0，0），那计算转换后的坐标焦点就成了（30，30），即坐标从（0，0）转换到了（30，30）。简而言之现在的transform： matrix(1,0,0,1,30,30)就相当于transform： translate(30px,30px)，这里值得要注意的地方是 translate，shew，scale，rotate 都是需要写上单位的。总结下来你就会发现 matrix 表现偏移就是 matrix(无关，无关，无关，无关，水平偏移，垂直偏移) 剩下的也就不必多说了，缩放对应的参数是 a和d ，拉伸和旋转涉及到三角函数不想说话，拉伸和旋转其实使用 shew和rotate 比使用 matrix 更为方便。 属性值：transition该属性包括：transition-propety ：设置变换的属性名称，默认为all，也可以指定特定的属性变换transition-duration ：设置过度需要的时间transition-timing-function ：规定速度效果的速度曲线，默认为ease（规定慢速开始，然后变快，然后慢速结束的过渡效果），其他的还有linear（规定以相同速度开始至结束的过渡效果）ease-in（规定以慢速开始的过渡效），ease-out（规定以慢速结束的过渡效果）和ease-in-out（规定以慢速开始和结束的过渡效果）。transition-delay ：定义过度效果何时开始 2.css动画keyframes 介绍在css3中以@keyframes开始 后面跟上动画名称加{…}动画内容。 animation 属性介绍animation-name ：要运行的动画名称animation-during ：设置动画播放时间animation-timing-function ：设置动画开始方式 （属性值与transition-timing-function相同）animation-delay ：设置动画延后执行时间animation-iteration-count ：设置动画的播放次数，通常为整数，如果设置为 infinte则一直循环动画animation-direction ：设置动画的播放方向，默认值为 normal（每次都是向前播放），如果设置为 alternate （动画播放在第偶数次向前播放，第奇数次向反方向播放）。","tags":[{"name":"css3","slug":"css3","permalink":"http://wangcheng007.github.io/tags/css3/"},{"name":"简单","slug":"简单","permalink":"http://wangcheng007.github.io/tags/简单/"}]}]